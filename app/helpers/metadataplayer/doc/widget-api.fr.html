<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Metadataplayer docs: widget-api.fr</title>
</head>
<body>
<h1>API de programmation de widgets</h1>
<p>ATTENTION !
Cette documentation se réfère à la dernière version du Metadataplayer, disponible dans la branche <strong>default</strong> du repository
http://www.iri.centrepompidou.fr/dev/hg/metadataplayer</p>
<h2>Types et fichiers</h2>
<p>Les widgets sont créés au moment de l’instanciation du Metadataplayer, en lisant la propriété <em>gui.widgets</em> des paramètres de configuration.</p>
<p>Exemple:</p>
<pre><code>var monPlayer = new IriSP.Metadataplayer({
    player: {...},
    gui: {
        container: ...,
        widgets: [
            {
                type: "Slider"
            },
            {
                type: "Controller"
            },
            {
                type: "MonWidget",
                option: "valeur"
            },
            ...
        ]
    }
});
</code></pre>
<p>Le <em>type</em> du widget détermine quels fichiers, javascript et CSS, seront appelés et quelle classe d'objet sera instanciée.</p>
<p>Par exemple, pour le <em>type</em> <strong>MonWidget</strong>, seront appelés <strong>MonWidget.js</strong>, <strong>MonWidget.css</strong> et l’initialisation du widget se fera en appelant la classe <strong>IriSP.Widgets.MonWidget</strong></p>
<p>Le fichier <strong>MonWidget.js</strong> doit donc contenir une implémentation de <strong>IriSP.Widgets.MonWidget</strong></p>
<h2>Implémentation d’une classe de widget</h2>
<p>La classe de Widget doit hériter de IriSP.Widgets.Widget. Le code permettant l’héritage est le suivant:</p>
<pre><code>IriSP.Widgets.MonWidget = function(player, config) {
    IriSP.Widgets.Widget.call(this, player, config);
}

IriSP.Widgets.MonWidget.prototype = new IriSP.Widgets.Widget();
</code></pre>
<h3>Paramètres d’appel de l’objet Widget</h3>
<p>Le paramètre <strong>player</strong> correspond à l’objet IriSP.Metadataplayer qui a appelé le widget.</p>
<p>Il sera ensuite accessible dans les fonctions du widget par:</p>
<pre><code>this.player
</code></pre>
<p>Le paramètre <strong>config</strong> correspond aux paramètres de configuration du widget. Dans notre exemple, il s’agit d’un objet contenant:</p>
<pre><code>{
    type: "MonWidget",
    option: "valeur de l’option"
}
</code></pre>
<p>Les options de configuration sont recopiées dans les propriétés de l’objet widget:</p>
<pre><code>this.type    =&gt; "MonWidget"
this.option  =&gt; "valeur de l’option"
</code></pre>
<h3>Propriétés accessibles par le widget</h3>
<h4>Media</h4>
<p>Les fonctions de gestion de la lecture vidéo sont accessibles via les objets <strong>media</strong>.</p>
<p>Par exemple:</p>
<pre><code>this.media.trigger("Evenement"); =&gt; déclenche un événement Popcorn de type "Evenement"
this.media.play();               =&gt; met le player en lecture
this.media.currentTime()         =&gt; obtient le timecode courant, en secondes
</code></pre>
<h4>Source de métadonnées</h4>
<p>La source de métadonnées est accessible par la propriété <strong>source</strong> du Widget.</p>
<p>Par exemple:</p>
<pre><code>this.source.getAnnotations();  =&gt; obtient la liste des annotations
this.source.getDuration();     =&gt; obtient la durée du média en cours, en millisecondes
</code></pre>
<h4>Sélecteur jQuery</h4>
<p>Le contenu du widget est géré par la bibliothèque jQuery. Pour accéder à ce contenu, il suffit d’appeller la propriété <strong>$</strong> du widget</p>
<p>Par exemple:</p>
<pre><code>this.$.html();                         =&gt; renvoie le code HTML contenu dans le widget.
this.$.find("p").html("Hello, world")  =&gt; écrit "Hello, world" dans le(s) élément(s) &lt;P&gt; du widget.
</code></pre>
<h3>Fonctions facilitatrices du widget</h3>
<p>Quelques fonctions ont été rajoutées pour faciliter quelques tâches courantes:</p>
<h4>getWidgetAnnotations</h4>
<p>Retourne la liste des annotations selon la valeur de la propriété <strong>annotation_type</strong> du widget:
    - Chaîne de caractères: prend en compte les types d’annotations dont le titre contient la chaîne. Exemple: "chap" permet notamment d’afficher les annotations dans le type d’annotation "Chapitrage"
    - Tableau de chaînes: pour prendre en compte plusieurs types d’annotations
    - false: pour prendre en compte toutes les annotations du projet</p>
<pre><code>this.getWidgetAnnotations();
</code></pre>
<h4>functionWrapper</h4>
<p>Gère l’accès au fonctions du widget dans des callbacks. Ceci sert à pallier au fait qu’en Javascript, appeler directement une fonction dans un callback ne l’applique pas à l’objet dans lequel elle a été appelée.</p>
<p><strong>functionWrapper</strong> demande un argument, une chaîne qui est le nom de la fonction à appeler.</p>
<p>Par exemple:</p>
<pre><code>this.$.click(this.functionWrapper("onClick"));  =&gt; Appellera this.onClick() lors d’un click sur le widget
</code></pre>
<h4>onMediaEvent</h4>
<p>Attache un événement <em>Media</em> ("play", "timeupdate", ...) à une fonction désignée
- par son nom, quand celle-ci est une méthode du widget, ce qui permet de l’associer directement au widget, sur le même mode que <em>functionWrapper</em>
- comme fonction anonyme</p>
<p>Par exemple:</p>
<pre><code>this.onMediaEvent("timeupdate","onTimeupdate");                =&gt; Appellera this.onTimeupdate() lorsque l’événement media "timeupdate" est déclenché.
this.onMediaEvent("play", function() { console.log("play") }); =&gt; Affichera "play" dans la console JavaScript
</code></pre>
<h4>onMdpEvent</h4>
<p>Attache un événement Metadataplayer global ("Annotation.show", "search.found", ...) à une fonction. Utilisé de manière similaire à onMediaEvent.</p>
<h4>Autres fonctions</h4>
<p>Les fonctions relatives aux gabarits seront explicités dans la section Gabarits</p>
<h3>Implémentation de la fonction draw</h3>
<p>La fonction <strong>draw()</strong> est appelée automatiquement lorsque les métadonnées ont fini d’être chargées. C’est le lieu privilégié pour les fonctions gérant l’apparence du widget.</p>
<pre><code>IriSP.Widgets.MonWidget.prototype.draw = function() {
    this.$.html("Hello, world");
}
</code></pre>
<h2>Utilisation des gabarits</h2>
<p>Les gabarits ou <em>templates</em> en anglais permettent d’injecter des données dans du code HTML.</p>
<h3>Utilisation de Mustache</h3>
<p>Le Metadataplayer utilise la bibliothèque <em>Mustache.js</em> pour réaliser cette opération.</p>
<p>Voici un exemple d’utilisation de <em>Mustache</em> seul:</p>
<pre><code>var gabarit = "&lt;b&gt;{{hello}}&lt;/b&gt;, {{world}}";
var donnees = {
    hello: "Bonjour",
    world: "monde"
}
Mustache.to_html(gabarit, donnees);           =&gt; "&lt;b&gt;Bonjour&lt;/b&gt;, monde"
</code></pre>
<h3>templateToHtml</h3>
<p>Les gabarits sont souvent utilisés directement avec les propriétés du widget. Un raccourci existe pour injecter directement celles-ci dans un gabarit:</p>
<pre><code>this.templateToHtml("&lt;h3&gt;{{type}}&lt;/h3&gt;&lt;p&gt;{{option}}&lt;/p&gt;");  =&gt; "&lt;h3&gt;MonWidget&lt;/h3&gt;&lt;p&gt;valeur de l’option&lt;/p&gt;"
</code></pre>
<h3>renderTemplate</h3>
<p>Dans les cas les plus fréquents, le gabarit sera implémenté directement dans la propriété <em>template</em> du widget, par exemple:</p>
<pre><code>IriSP.Widgets.MonWidget.prototype.template = "&lt;h3&gt;{{type}}&lt;/h3&gt;&lt;p&gt;{{option}}&lt;/p&gt;";
</code></pre>
<p>De plus, le code généré par le gabarit a pour vocation d’être rajouté directement au contenu du widget, généralement à l’intérieur de la fonction draw(). Ceci peut être réalisé avec la fonction <em>renderTemplate</em>.</p>
<pre><code>this.renderTemplate();   =&gt; ajoute directement "&lt;h3&gt;MonWidget&lt;/h3&gt;&lt;p&gt;valeur de l’option&lt;/p&gt;" dans le code HTML du widget
</code></pre>
<h2>Internationalisation du widget</h2>
<p>Le Metadataplayer a été conçu pour être multilingue. Pour ceci, les différents textes de l’interface doivent être séparés du reste du code et des gabarits.</p>
<h3>Définition des textes</h3>
<p>Les textes sont définis dans la propriété <strong>messages</strong> du widget et regroupés par langue, dans un objet dont les clés sont les codes ISO 639-1 de la langue. Chaque langue est elle-même un objet, associant un nom de texte unique à sa traduction.</p>
<pre><code>IriSP.Widgets.MonWidget.prototype.message = {
    en: {
        hello: "Hello",
        world: "world"
    },
    fr: {
        hello: "Bonjour",
        world: "monde"
    }
}
</code></pre>
<h3>Accès aux textes dans la langue de l’interface</h3>
<p>La langue de l’interface est définie par <em>IriSP.language</em>. Un accès direct aux messages se fait par la propriété <em>l10n</em> (raccourci pour "localization") du widget.</p>
<pre><code>this.l10n.hello;   =&gt; "Hello" si l’interface est en anglais, "Bonjour" si l’interface est en français.
</code></pre>
<h3>Accès aux textes dans un gabarit</h3>
<p>Cette propriété <em>l10n</em> permet d’accéder directement aux textes dans les gabarits:</p>
<pre><code>this.templateToHtml("{{l10n.hello}}, {{l10n.world}}!");  =&gt; "Hello, world!" en anglais ou "Bonjour, monde!" en français.
</code></pre>
</body>
</html>